import express from 'express';
import { v4 as uuidv4 } from 'uuid';
import type { AgentCard, Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent, Message } from '@a2a-js/sdk';
import {
  AgentExecutor,
  RequestContext,
  ExecutionEventBus,
  DefaultRequestHandler,
  InMemoryTaskStore,
} from '@a2a-js/sdk/server';
import { A2AExpressApp } from '@a2a-js/sdk/server/express';
import { createOpenAI } from '@ai-sdk/openai';
import { generateText } from 'ai';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import { URL } from 'url';

dotenv.config();

// Load Agent Card from .agent-card.json
const agentCard: AgentCard = JSON.parse(fs.readFileSync('.agent-card.json', 'utf8'));

// Override URL from environment if present
if (process.env.AGENT_URL) {
  agentCard.url = process.env.AGENT_URL;
}

// Ensure capabilities are set
if (!agentCard.capabilities) {
  agentCard.capabilities = {};
}
agentCard.capabilities.streaming = true;
agentCard.capabilities.pushNotifications = true;

// Initialize OpenAI (optional - for AI capabilities)
const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY || 'dummy-key',
});

/**
 * Executor - Implements the core agent logic
 * 
 * This executor processes incoming messages from users and generates responses.
 * It demonstrates:
 * 1. Task creation and management (A2A Task Protocol)
 * 2. Streaming status updates (submitted -> working -> completed)
 * 3. Generating and sending Artifacts
 * 4. Handling Cancellation
 * 5. AI integration
 */
class Executor implements AgentExecutor {
  // Map to store AbortControllers for active tasks to support cancellation
  private activeTasks = new Map<string, AbortController>();

  async execute(
    requestContext: RequestContext,
    eventBus: ExecutionEventBus
  ): Promise<void> {
    const { taskId, contextId, userMessage, task } = requestContext;
    
    // Create an AbortController for this task
    const controller = new AbortController();
    this.activeTasks.set(taskId, controller);

    try {
      // 1. Initialize Task if needed
      // If the request didn't come with an existing task, we create one to track state.
      if (!task) {
        const initialTask: Task = {
          kind: 'task',
          id: taskId,
          contextId: contextId,
          status: {
            state: 'submitted',
            timestamp: new Date().toISOString(),
          },
          history: [userMessage]
        };
        eventBus.publish(initialTask);
      }

      // Extract user's message text
      const userText = userMessage?.parts?.find(p => p.kind === 'text')?.text || '';
      console.log(`[${taskId}] üì© Message received: "${userText}"`);

      // 2. Update Status to 'working'
      // This informs the client that the agent has accepted the task and is processing.
      const workingUpdate: TaskStatusUpdateEvent = {
        kind: 'status-update',
        taskId,
        contextId,
        status: { state: 'working', timestamp: new Date().toISOString() },
        final: false
      };
      eventBus.publish(workingUpdate);

      // Check for cancellation before starting heavy work
      if (controller.signal.aborted) return;

      // 3. Generate Response (Simulate long running task or use AI)
      let responseText: string;
      
      if (process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY !== 'dummy-key') {
        try {
          console.log(`[${taskId}] üß† Calling OpenAI to generate response...`);
          
          // We can send an artifact to show "thinking" or intermediate steps
          eventBus.publish({
            kind: 'artifact-update',
            taskId,
            contextId,
            artifact: {
              artifactId: `thought-${Date.now()}`,
              name: 'Thought Process',
              parts: [{ kind: 'text', text: 'Analyzing your request...' }]
            }
          });

          const { text } = await generateText({
            model: openai('gpt-4-turbo'),
            prompt: `You are a helpful assistant named ${agentCard.name}. Respond to the user's message: "${userText}"`,
            abortSignal: controller.signal,
          });
          responseText = text || 'I apologize, but I could not generate a response.';
        } catch (error: any) {
          if (controller.signal.aborted || error.name === 'AbortError') {
            console.log(`[${taskId}] üõë AI generation aborted.`);
            return; // Exit gracefully
          }
          console.error(`[${taskId}]  OpenAI error:`, error.message);
          responseText = this.generateFallbackResponse(userText);
        }
      } else {
        // Simulate some "work" time for the demo
        console.log(`[${taskId}] ü§ñ Generating fallback response (simulating work)...`);
        await new Promise(resolve => setTimeout(resolve, 1000)); // 1s delay
        responseText = this.generateFallbackResponse(userText);
      }

      if (controller.signal.aborted) return;

      // 4. Publish Final Response as an Artifact or Message
      // In A2A, you can attach the main result as an artifact or just complete the task.
      // We'll attach the response as a text artifact for clarity, or just use a Message.
      // Usually, we send a 'message' event if it's a chat reply.
      
      const responseMessage: Message = {
        kind: 'message',
        messageId: uuidv4(),
        role: 'agent',
        parts: [{ kind: 'text', text: responseText }],
        contextId: contextId,
      };
      eventBus.publish(responseMessage);

      // 5. Mark Task as Completed
      const completedUpdate: TaskStatusUpdateEvent = {
        kind: 'status-update',
        taskId,
        contextId,
        status: { state: 'completed', timestamp: new Date().toISOString() },
        final: true,
      };
      eventBus.publish(completedUpdate);
      eventBus.finished();

      console.log(`[${taskId}] üì§ Response sent and task completed.`);

    } catch (error: any) {
      console.error(`[${taskId}] üí• Error during execution:`, error.message);
      
      // Publish error status
      const errorUpdate: TaskStatusUpdateEvent = {
        kind: 'status-update',
        taskId,
        contextId,
        status: { state: 'failed', timestamp: new Date().toISOString() },
        final: true,
      };
      eventBus.publish(errorUpdate);
      
      // Also send a helpful error message
      const errorMessage: Message = {
        kind: 'message',
        messageId: uuidv4(),
        role: 'agent',
        parts: [{ 
          kind: 'text', 
          text: `I encountered an error processing your request: ${error.message}` 
        }],
        contextId: contextId,
      };
      eventBus.publish(errorMessage);
      eventBus.finished();
    } finally {
      // Cleanup
      this.activeTasks.delete(taskId);
    }
  }

  /**
   * Generate a simple fallback response when AI is not available
   */
  private generateFallbackResponse(userText: string): string {
    const lowerText = userText.toLowerCase();
    
    if (lowerText.includes('hello') || lowerText.includes('hi')) {
      return `Hello! I'm ${agentCard.name}, your AI assistant. How can I help you today?`;
    }
    
    if (lowerText.includes('help')) {
      return 'I\'m here to help! You can ask me questions or chat with me. ' +
             'For better responses, configure an OpenAI API key in your .env file.';
    }
    
    if (lowerText.includes('what') && lowerText.includes('do')) {
      return 'I\'m an A2A-compliant AI agent. I can understand your messages and provide helpful responses. ' +
             'Try asking me questions or chatting with me!';
    }
    
    // Default echo response
    return `You said: "${userText}". I'm currently running in simple mode. ` +
           `Configure OPENAI_API_KEY in .env for AI-powered responses!`;
  }

  /**
   * Handle task cancellation
   * This is called when a user cancels a long-running task
   */
  async cancelTask(taskId: string, eventBus: ExecutionEventBus): Promise<void> {
    console.log(`[${taskId}] üõë Task cancellation requested`);
    
    const controller = this.activeTasks.get(taskId);
    if (controller) {
      controller.abort();
      this.activeTasks.delete(taskId);
    }

    // Publish cancelled status
    const cancelledUpdate: TaskStatusUpdateEvent = {
      kind: 'status-update',
      taskId,
      contextId: 'unknown', // Often contextId is passed in execute, strictly we might need to store it or pass it here
      status: { state: 'canceled', timestamp: new Date().toISOString() },
      final: true,
    };
    eventBus.publish(cancelledUpdate);
    eventBus.finished();
  }
}

// Initialize A2A Server
const port = process.env.PORT
  ? parseInt(process.env.PORT, 10)
  : new URL(agentCard.url).port;
const agentExecutor = new Executor();
const taskStore = new InMemoryTaskStore();
const requestHandler = new DefaultRequestHandler(
  agentCard,
  taskStore,
  agentExecutor
);
const appBuilder = new A2AExpressApp(requestHandler);

// Setup Express app and A2A routes
const app = appBuilder.setupRoutes(express());

// Security: Check X-OpenHive-Secret header (when deployed)
if (process.env.NODE_ENV === 'production' && process.env.OPENHIVE_SECRET) {
  app.use((req, res, next) => {
    const secret = req.headers['x-openhive-secret'];
    if (secret !== process.env.OPENHIVE_SECRET) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  });
}

// Start server
app.listen(port, () => {
  console.log(`üöÄ A2A Agent "${agentCard.name}" listening on port ${port}`);
  console.log(`üìã Agent Card: http://localhost:${port}/.well-known/agent-card.json`);
  console.log(`üîß Skills: ${agentCard.skills.map((s) => s.id).join(', ')}`);
  console.log();
  console.log('üí° Try sending a message:');
  console.log("   - 'Hello'");
  console.log("   - 'What can you do?'");
  console.log("   - 'Help me with something'");
  console.log();
  
  if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'dummy-key') {
    console.log('‚ö†Ô∏è  No OPENAI_API_KEY found - running in simple mode');
    console.log('   Set OPENAI_API_KEY in .env for AI-powered responses');
    console.log();
  }
});
